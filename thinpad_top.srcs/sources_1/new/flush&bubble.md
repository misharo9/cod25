## 流水线 CPU 的设计与实现 - 气泡和冲刷流水线

在设计流水线 CPU 时，一定会遇到冲突的问题。有时需要向流水线中插入气泡，有时需要冲刷掉流水线的部分阶段，除去错误的指令。

另一方面，在有 Wishbone 总线存在的情况下，无法在单周期内完成访存，一条指令可能要在 IF 段和 MEM 段停留多个周期，这时我们也需要加入气泡来填满流水线。

本节将会提出要考虑的问题以及对这些问题的提示，同学们在设计时可以参考这些思路。

## 简单情况下的 stall 和 flush 设计

我们先考虑在访存只需要一个周期时的流水线行为。

对于每个流水线段寄存器我们都需要增加以下两个输入：

一段伪代码如下：

对于每个流水线段（组合逻辑），我们需要增加以下输出信号：

我们观察下面几种情况时，对应信号的值：

1.  ID 阶段发现数据冲突，需要阻塞流水线
    
    假设在周期 0 发现冲突，此时流水线中指令如下：
    
    | IF | ID | EXE | MEM | WB |
    | --- | --- | --- | --- | --- |
    | A | B | C | D | E |
    
    则周期 1 时，流水线中指令应该如下表所示（bub 表示气泡）：
    
    | IF | ID | EXE | MEM | WB |
    | --- | --- | --- | --- | --- |
    | A | B | bub | C | D |
    
    此时应该为 ID 段在周期 0 发出 stall\_o 请求，流水线寄存器的控制信号一个合理的输入如下表:
    
    | 寄存器 | stall\_i | bubble\_i |
    | --- | --- | --- |
    | if\_id | 1 | 0 |
    | id\_ex | 0 | 1 |
    | ex\_mem | 0 | 0 |
    | mem\_wb | 0 | 0 |
    
2.  EXE 需要跳转，需要冲刷流水线
    
    假设在周期 0 发现冲突，此时流水线中指令如下：
    
    | IF | ID | EXE | MEM | WB |
    | --- | --- | --- | --- | --- |
    | A | B | C | D | E |
    
    则周期 1 时，流水线中指令应该如下表所示（bub 表示气泡）：
    
    | IF | ID | EXE | MEM | WB |
    | --- | --- | --- | --- | --- |
    | F | bub | bub | C | D |
    
    此时应该为 EXE 段在周期 0 发出 flush\_o 请求，流水线寄存器的控制信号一个合理的输入如下表：
    
    | 寄存器 | stall\_i | bubble\_i |
    | --- | --- | --- |
    | if\_id | 0 | 1 |
    | id\_ex | 0 | 1 |
    | ex\_mem | 0 | 0 |
    | mem\_wb | 0 | 0 |
    
3.  上面两种情况同时发生
    
    此时应该为 ID 段在周期 0 发出 stall\_o 请求，同时 EXE 段在周期 0 发出 flush\_o 请求。
    
    流水线寄存器的控制信号一个合理的输入如下表：
    
    | 寄存器 | stall\_i | bubble\_i |
    | --- | --- | --- |
    | if\_id | 0 | 1 |
    | id\_ex | 0 | 1 |
    | ex\_mem | 0 | 0 |
    | mem\_wb | 0 | 0 |
    

大家可以先考虑所有可能的请求情况，然后尝试实现一个单元来根据每段请求，向流水线寄存器发送对应的控制信号。

## 复杂情况下的 stall 和 flush 设计

注意在引入 Wishbone 总线之后，IF 和 MEM 这两个阶段都可能需要多个周期才能够完成，这让事情变得更加复杂。

比如在 EXE 段发生跳转时，你不能直接更新 PC，因为这会导致 Wishbone 总线上的地址发生改变，从而产生错误。

这里给出两种解决思路：

下面给出第一种解决思路的一个例子：

假设在周期 0 时，流水线中指令如下：

| IF | ID | EXE | MEM | WB |
| --- | --- | --- | --- | --- |
| A | B | C | D | E |

D 指令为 load 指令，C 指令不访存。

`xx_master_ready` 表示总线当前请求已经完毕，可以开始执行下一条指令。

`pipeline_stall` 表示是否完全阻塞流水线。

一个合理的波形如下：

time0123456789101112clockif\_master\_stbif\_master\_ackif\_master\_readymem\_master\_stbmem\_master\_ackmem\_master\_readypipeline\_stall

注意到 8 时刻流水线不再阻塞，所以在 9 时刻时，流水线中指令如下：

| IF | ID | EXE | MEM | WB |
| --- | --- | --- | --- | --- |
| F | A | B | C | D |

大家也可以考虑更加复杂的控制逻辑，但这已经超出实验五的要求了。在大实验中，如果想要更好的性能，需要使用性能更好的方法。

* * *

最后更新: 2025年11月9日